# 函数和函数式编程

## 一.函数概述
- 函数是可重复使用的程序代码段，用于在程序中分离不同的任务
- 函数允许程序的控制在调用代码和函数代码之间切换，也可以把控制转换到自身的函数（函数自己调用本身），称为递归调用

### 1.1 函数的功能
- 实现结构化程序设计
- 减少程序的复杂度
- 实现代码的复用
- 提高代码的质量
- 协作开发
- 实现特殊功能

### 1.2 函数的分类
- 内置函数
- 标准库函数
- 第三方库函数
- 用户自定义函数

## 二.函数的声明和调用
### 2.1 函数对象的创建
```python
def 函数名([形参列表]):
'''
函数签名（signature） --> 用于指定函数名称和函数每个形参变量的名称
'''
     函数体
```

1. 使用关键字 `def` 声明，函数名为有效的标识符：__全小写字母，可以用下划线增加可读性__
2. __形参列表__：用圆括号 `()` 括起来，并用逗号隔开，可以为空；在调用函数时，需要提供形参的值
3. 函数体需要采用 __缩进书写__ 规则
4. `return` : 有 `return` 语句返回值，否则不返回值或返回值为空（`None`）
5. `def` 是执行语句，会创建一个函数对象，并绑定到函数名变量

### 2.2 函数的调用
 ```python
函数名([实参列表])  
 ```
1. 函数名是当前作用域可用的函数对象，在调用函数之前程序需先执行 `def` 语句，创建函数对象
2. 函数的定义位置必须位于该函数的全局代码之前，即 __`import` 语句>函数定义>全局代码__
3. 实参列表必须和函数定义的形参列表 __一一对应__
4. 函数调用是 __表达式__ ：如果函数有返回值，可以在表达式中直接使用；如果函数没有返回值，可以单独作为表达式语句使用

### 2.3 函数的副作用 

1. __纯函数__：函数的返回值只依赖于函数的参数，不依赖于函数外部的变量值，也不依赖于函数内部的变量值
2. __函数的副作用__：函数调用会产生副作用，函数调用会执行函数体的语句，包括变量赋值、函数调用、`print()` 函数调用、`return` 语句


### 2.4 `lambda` 表达式和匿名函数
1. 用户可以使用 `lambda` 表达式直接定义匿名函数（广泛适用于需要函数对象作为参数、函数比较简单并且只使用一次的场合）
2. `lambda` 是一种简便的、在同一行中定义函数的方法，实际上生成了一个函数对象（匿名函数）
```python
lambda arg1,arg2,... :<expression>
'''
arg1,arg2 是函数的参数，<expression>是函数的语句，其结果为函数的返回值
'''
```
## 三.参数的传递
### 3.1 形式参数和实际参数
- __形式参数__：定义函数时，函数名后面的括号中的参数称为形式参数，简称形参。
- __实际参数__：调用函数时，函数名后面的括号中的参数称为实际参数，简称实参。
- 实际参数值默认按照位置顺序依次传递给形式参数，如果参数个数不对，则会产生错误

### 3.2 形式参数变量和对象引用传递
- 声明的形式参数等同于函数体中的局部变量，在函数体中的任何位置都可以使用
- 局部变量和形式参数变量的区别：局部变量在函数体中绑定到某个对象，而形式参数变量则绑定到函数调用代码时传递的对应实际参数对象
- python 参数传递方法是传递对象引用，而不是传递对象的值

### 3.3 传递不可变对象的引用
- 在调用对象时，如果传递的是不可变对象的引用，则如果函数体中修改对象的值，其结果是创建了一个新的对象
- 函数不可以改变不可变对象的值
- 错误示范：
```python
i = 100
def inc(j,n):
    j = j + n

inc(i,10)  # 输出仍为100
```
- 正确示例
```python
i = 100
def inc(j,n):
    j = j + n
    return j  
i = inc(i,10)  # 输出为110
```

### 3.4 传递可变对象的引用
- 在调用函数时，如果传递的是可变对象的引用，则函数体中可以直接改变对象的值

### 3.5 可选参数
- 如果希望函数的一些参数是可选的，可以在声明函数是为这些函数指定默认值，若未传入相应的实参，则用默认值
```python
def 函数名(a,b,c=10):
    函数体
# 如果没传入c，则c的值为10
```
- 必须先声明没有默认值的形参，然后再声明有默认值的形参

### 3.6 位置参数和命名参数（关键字参数）
- __位置参数__：在函数调用时，实参默认按位置顺序传递形参，这种按位置传递的参数为位置参数
- __命名参数__：按名称指定传入的参数
   - 参数按名称意义明确
   - 传递的参数与顺序无关
   - 如果有多个可选参数，则可以选择指定某个参数值
- 在带星号的参数后面声明的参数强制为命名参数，如果这些参数没有默认值，且调用时没有指定这些参数的名称，则会产生错误


### 3.7 可变参数（打包参数）和解包参数
- 可变参数：

 `*args` : 向函数传递可变数量的实参，在调用函数时，从那一点往后的参数被收集为一个元组
   
` **kwargs` ：向函数传递可变数量的实参，在调用函数时，从那一点往后的参数被收集为一个字典
    必须位于形参列表的最后位置

```python
    def func(*args, **kwargs):
        print(args)
        print(kwargs)

    func(1, 2, 3, a=4, b=5, c=6)
    # (1, 2, 3)
    # {'a': 4, 'b': 5, 'c': 6}
```
- 解包参数：
```python
     在函数调用中，一个*号能够将序列解包为不同的参数，一个**号能够将字典解包为不同的参数，使其成为独立的关键字参数
     def func(a, b, c):
         print(a, b, c)

     lst = [1, 2, 3]
     dic = {'a': 4, 'b': 5, 'c': 6}
     func(*lst)  # 1 2 3   等价于 func(1, 2, 3)
     func(**dic)  # 4 5 6  等价于 func(a=4, b=5, c=6)

```

##### （八）强制命名参数（Keyword-only）
- 在带星号的参数后面声明参数会导致强制命名参数，在调用时必须显式使用命名参数传递值，而按位置传递的参数默认收集为一个元组，传递给前面带星号的可变参数。 
- 如果不需要带星的可变参数，只想使用强制命名参数，可以只采用一个星号：
```python
    def func(*, a, b, c):
        print(a, b, c)

    func(a=1, b=2, c=3)  # 1 2 3
    func(1, 2, 3)  # TypeError: func() takes 0 positional arguments but 3 were given
```

##### （九）参数类型检查和参数注解
- 函数在定义时纪要指定定义域也要指定值域（即指定形式参数和返回值的类型）：
- 但定义函数时，也不用限定其参数和返回值的类型，这种灵活性可以实现多态性
## 四.函数的返回值

## 五.变量的作用域

## 六.递归函数
