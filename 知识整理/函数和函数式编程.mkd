# 函数和函数式编程
![](/图片文件/函数/函数和函数式编程.svg?raw=true)
![](/python期末复习/图片文件/函数/函数和函数式编程.svg?raw=true)
## 一.函数概述
- 函数是可重复使用的程序代码段，用于在程序中分离不同的任务
- 函数允许程序的控制在调用代码和函数代码之间切换，也可以把控制转换到自身的函数（函数自己调用本身），称为递归调用

### 1.1 函数的功能
- 实现结构化程序设计
- 减少程序的复杂度
- 实现代码的复用
- 提高代码的质量
- 协作开发
- 实现特殊功能

#### 扩展：程序模块化
![](/图片文件/函数/程序模块化.svg?raw=true)
![](/python期末复习/图片文件/函数/程序模块化.svg?raw=true)
__1. 程序模块化__ 是指将程序划分为若干个功能相对独立的模块，每个模块完成一个特定的功能

__2. 分而治之，自顶向下，逐步细化__

- 在设计程序时，依据需求对程序要完成的任务进行分解，把完成每一个任务的程序代码定义为一个函数
- 对于复杂程序，一个模块要完成的任务往往需要进一步分解为若干个子任务，如果子任务不够简单，则可以继续进行分解，直至各个子任务足够具体

__3. 程序模块__
- 程序模块可能包含多个自定义函数、自定义类和全局变量等
- 在Python中，把一个 `.py` 文件称为一个模块，模块名就是文件名去掉 `.py` 后缀，在程序文件中可以定义函数、全局变量、类和对象等

__4. 通过函数实现程序模块化__
- 函数是实现结构化程序必不可少的工具
    * 将可能需要反复执行的代码封装为函数，并在需要该功能的地方进行调用
    * 不仅可以实现代码复用，更重要的是可以保证代码的一致性
- 设计函数时，应注意提高模块的内聚性，同时降低模块之间的隐式耦合




### 1.2 函数的分类
__1. 内置函数__

Python语言内置了若干常用的函数（在内置模块 `__builtins__` 中），在程序中可以直接使用

__2. 标准库函数__

Python语言安装程序同时会安装若干标准库模块

详见 `Python标准库.mkd` 文件

__3. 第三方库函数__

Python社区提供了许多其他高质量的库

下载这些库后，通过`import`语句导入到程序中，即可使用这些库提供的函数


__4. 用户自定义函数__
用户根据自己的需求，使用 `def` 语句定义函数

## 二.函数的声明和调用
![](/图片文件/函数/函数的声明和调用.svg?raw=true)
![](/python期末复习/图片文件/函数/函数的声明和调用.svg?raw=true)
### 2.1 函数对象的创建
```python
def 函数名([形参列表]):
'''
函数签名（signature） --> 用于指定函数名称和函数每个形参变量的名称
'''
     函数体
```

1. 使用关键字 `def` 声明，函数名为有效的标识符：__全小写字母，可以用下划线增加可读性__
2. __形参列表__：用圆括号 `()` 括起来，并用逗号隔开，可以为空；形参不需要声明类型，也不需要指定函数返回值类型；在调用函数时，需要提供形参的值
3. 函数体需要采用 __缩进书写__ 规则
4. `return` : 有 `return` 语句返回值，否则不返回值或返回值为空（`None`）
5. `def` 是执行语句，会创建一个函数对象，并绑定到函数名变量

### 2.2 函数的调用
 ```python
函数名([实参列表])  
 ```
1. 函数名是当前作用域可用的函数对象，在调用函数之前程序需先执行 `def` 语句，创建函数对象
2. 函数的定义位置必须位于该函数的全局代码之前，即 __`import` 语句>函数定义>全局代码__
3. 实参列表必须和函数定义的形参列表 __一一对应__
4. 函数调用是 __表达式__ ：如果函数有返回值，可以在表达式中直接使用；如果函数没有返回值，可以单独作为表达式语句使用

### 2.3 函数的副作用 

1. __纯函数__：函数的返回值只依赖于函数的参数，不依赖于函数外部的变量值，也不依赖于函数内部的变量值
2. __函数的副作用__：函数调用会产生副作用，函数调用会执行函数体的语句，包括变量赋值、函数调用、`print()` 函数调用、`return` 语句


### 2.4 `lambda` 表达式和匿名函数
1. 用户可以使用 `lambda` 表达式直接定义匿名函数（广泛适用于需要函数对象作为参数、函数比较简单并且只使用一次的场合）
2. `lambda` 是一种简便的、在同一行中定义函数的方法，实际上生成了一个函数对象（匿名函数）
```python
lambda arg1,arg2,... :<expression>
'''
arg1,arg2 是函数的参数，<expression>是函数的语句，其结果为函数的返回值
'''
```
## 三.参数的传递
![](/图片文件/函数/参数的传递.svg?raw=true)
![](/python期末复习/图片文件/函数/参数的传递.svg?raw=true)
### 3.1 形式参数和实际参数
- __形式参数__：定义函数时，函数名后面的括号中的参数称为形式参数，简称形参。
- __实际参数__：调用函数时，函数名后面的括号中的参数称为实际参数，简称实参。
- 实际参数值默认按照位置顺序依次传递给形式参数，如果参数个数不对，则会产生错误
- __参数传递__：形式参数是变量，形式上是一个标识符，实际参数是一个对象，在函数调用时，将实际参数的值传递给形式参数，函数执行时，形参指向实参的对象

### 3.2 形式参数变量和对象引用传递
- 声明的形式参数等同于函数体中的局部变量，在函数体中的任何位置都可以使用
- 局部变量和形式参数变量的区别：局部变量在函数体中绑定到某个对象，而形式参数变量则绑定到函数调用代码时传递的对应实际参数对象
- python 参数传递方法是传递对象引用，而不是传递对象的值

### 3.3 传递不可变对象的引用
- 在调用对象时，如果传递的是不可变对象的引用，则如果函数体中修改对象的值，其结果是创建了一个新的对象
- 函数不可以改变不可变对象的值
- 错误示范：
```python
i = 100
def inc(j,n):
    j = j + n

inc(i,10)  # 输出仍为100
```
- 正确示例
```python
i = 100
def inc(j,n):
    j = j + n
    return j  
i = inc(i,10)  # 输出为110
```

### 3.4 传递可变对象的引用——以传递列表为例
- 在调用函数时，如果传递的是可变对象的引用，则函数体中可以直接改变对象的值
- 可以结合 `习题训练\函数和函数式编程.ipynb` 中 的

### 3.5 可选参数（默认值参数）
- 如果希望函数的一些参数是可选的，可以在声明函数是为这些参数指定默认值，若未传入相应的实参，则用默认值
```python
def 函数名(a,b,c=10):
    函数体
# 如果没传入c，则c的值为10
```
- ⚠ 必须先声明没有默认值的形参，然后再声明有默认值的形参

- 注意：
    * 可以使用 `函数名.__defaults__` 查看函数所有默认值参数的当前值，返回值为一个元组，元素依次表示为每个默认值参数的当前值
    * 多次调用函数并且不为默认值参数传递值时，默认值参数只在定义时进行一次解释和初始化，对于列表、字典这样可变类型的默认值参数，多次调用函数可能会产生错误
    * 一般来说，不应该使用可变类型的默认值参数，因为这会导致函数的行为不一致，应该使用不可变类型的默认值参数，或者在函数体中创建一个新的对象

eg：
```python
def func(a, b, c=[]):
    c.append(a)
    c.append(b)
    return c

print(func(1, 2))  # [1, 2]
print(func(3, 4))  # [1, 2, 3, 4],把c的默认值参数改变了
```
- 正确示例：
```python
def func(a, b, c = None):
    if c is None:
        c = []
    c.append(a)
    c.append(b)
    return c

print(func(1, 2))  # [1, 2]
print(func(3, 4))  # [3, 4]
```

### 3.6 位置参数和命名参数（关键字参数）
- __位置参数__：在函数调用时，实参默认按位置顺序传递形参，这种按位置传递的参数为位置参数
   - 位置参数必须按照定义的顺序传递
   - 按位置传递的实参的数量和顺序应该和形参表一致
- __命名参数__：按名称指定传入的参数
   - 参数按名称意义明确
   - 传递的参数与顺序无关
   - 如果有多个可选参数，则可以选择指定某个参数值
- 在带星号的参数后面声明的参数强制为命名参数，如果这些参数没有默认值，且调用时没有指定这些参数的名称，则会产生错误


### 3.7 可变参数（打包参数）和解包参数
__1. 可变参数（变长参数）：__
- 在函数调用时，可以接受任意多个实参的形参，这些实参会被打包为一个元组或字典传递给函数

- `*args` : 向函数传递可变数量的实参，在调用函数时，从那一点往后的参数被收集为一个元组
   
- ` **kwargs` ：向函数传递可变数量的实参，在调用函数时，从那一点往后的参数被收集为一个字典；其中键值必须为变量名，不能是字符串
- 必须位于形参列表的最后位置

```python
def func(*args, **kwargs):
    print(args)
    print(kwargs)

func(1, 2, 3, a=4, b=5, c=6)
# (1, 2, 3)
# {'a': 4, 'b': 5, 'c': 6}
```
__2. 解包参数：__

在函数调用中，一个*号能够将序列解包为不同的参数，一个**号能够将字典解包为不同的参数，使其成为独立的关键字参数
```python
def func(a, b, c):
     print(a, b, c)

lst = [1, 2, 3]
dic = {'a': 4, 'b': 5, 'c': 6}
func(*lst)  # 1 2 3   等价于 func(1, 2, 3)
func(**dic)  # 4 5 6  等价于 func(a=4, b=5, c=6)
```

### 3.8 强制命名参数（Keyword-only）
- 在带星号的参数后面声明参数会导致强制命名参数，在调用时必须显式使用命名参数传递值，而按位置传递的参数默认收集为一个元组，传递给前面带星号的可变参数。 
- 如果不需要带星的可变参数，只想使用强制命名参数，可以只采用一个星号：
```python
def func(*, a, b, c):
    print(a, b, c)

func(a=1, b=2, c=3)  # 1 2 3
func(1, 2, 3)  # TypeError: func() takes 0 positional arguments but 3 were given
```

### 3.9 参数类型检查和参数注解
- 函数在定义时纪要指定定义域也要指定值域（即指定形式参数和返回值的类型）：
- 但定义函数时，也不用限定其参数和返回值的类型，这种灵活性可以实现多态性




## 四.函数的返回值
在某些情况下，函数完成数值运算或数据处理后，要把结果反馈给调用函数，即 __函数返回值__

```python
    return [表达式]
```

__1.__ `return` 语句用于退出函数，选择性地向调用方返回一个表达式。不带参数值的 `return` 语句返回 `None`。

__2.__  函数中可以有多条 `return` 语句，执行到那一条 `return` 语句，哪一条 `return` 语句起作用，返回函数值并立即结束函数执行

__3.__  `return` 语句可以返回多个值，这些值会被放在一个元组中返回

__4. 返回元组__

* Python允许`return`语句把多个值打包到一个元组后返回
* 如果 `return` 语句后面是多个逗号隔开的数据，则系统自动把它们打包到一个元组中，作为返回值
* 返回值可以是任何组合类型的对象



## 五.变量的作用域
![](/图片文件/函数/变量的作用域.svg?raw=true)
![](/python期末复习/图片文件/函数/变量的作用域.svg?raw=true)
- 变量的可被访问范围被称为变量的作用域
- 作用域的分类：
    - 全局作用域：全局变量，在整个程序中都可以访问
    - 局部作用域：局部变量，只能在函数内部访问
    - 内置作用域：内置变量，在整个程序中都可以访问
    - 非局部作用域：在函数内部定义的函数，只能在该函数内部访问

### 5.1 命名空间（补充）
- 命名空间是一个用于储存变量名称和其对应对象的系统，确保名称的唯一性
- 命名空间可以看作是一个字典，其中变量名是键，变量值是值
- 命名空间的分类
    - 内置命名空间：内置函数和变量的命名空间，在程序启动时创建，在程序结束时销毁
    - 全局命名空间：模块级别的变量和函数的命名空间，在模块定义时创建，在模块执行结束时销毁 
    - 局部命名空间：函数内部的变量和函数的命名空间，在函数调用时创建，在函数执行结束时销毁 
- 命名空间的查找顺序：
    - 局部命名空间 -> 全局命名空间 -> 内置命名空间
    
### 5.2 全局变量
- 定义：在函数和类定义之外声明的变量
- 作用域：其定义的模块，从定义的位置起，直到文件结束位置
- 通过 `import` 语句导入模块，，并可以通过全限定名称 `模块名.变量名`访问；或通过 `from···import···` 语句导入变量，直接访问
- 注意：
    - 全局变量的作用域是全局的，在整个模块中都可以访问
    - 全局变量可以在函数内部使用，但不能直接修改
    - 如果在函数内部需要修改全局变量，可以使用 `global` 关键字声明变量为全局变量
- 全局变量降低了函数的通用性和可读性
- 全局变量一般作为常量使用

### 5.3 局部变量
- 定义：在函数体中定义的变量
- 作用域：其定义的函数，从定义的位置起，直到函数结束位置
- 如果在函数内部定义的变量与全局变量同名，则在函数内部使用的是局部变量
### 5.4 全局语句 `global`
- 在函数体中可以引用全局变量，但不能直接修改全局变量
- 如果需要在函数体中修改全局变量，可以使用 `global` 语句声明变量为全局变量
- 语法
```python
global 变量名1，变量名2，···
```
- 注意：
    - `global` 语句必须在函数体的第一行
    - 全局变量在函数内部使用时，需要先声明为全局变量

### 5.5 非局部语句 `nonlocal`
- 在函数体中可以定义嵌套函数，在嵌套函数中如果要为定义在上级函数体中的变量赋值，也可以使用 `nonlocal` 语句，表明变量不是所在块的局部变量，而是在上级函数体中的局部变量
- 语法
```python
nonlocal 变量名1，变量名2，···
```
- 注意：
    - `nonlocal` 语句必须在函数体的第一行
    - 非局部变量在函数内部使用时，需要先声明为非局部变量
### 5.6 类成员变量
- 定义：在类体中定义的变量
- 作用域：其定义的类，从定义的位置起，直到类结束位置
- 类成员变量可以在类的任何方法中使用，包括构造方法、实例方法、静态方法、类方法等
- 类成员变量可以通过类名或实例名访问
### 5.7 查看局部变量和全局变量
- 查看局部变量：`locals()`
- 查看全局变量：`globals()`
- 注意：
    - `locals()` 和 `globals()` 返回的是字典类型
    - `locals()` 返回的是当前局部变量的字典
    - `globals()` 返回的是当前全局变量的字典

## 六.递归函数
![](/图片文件/函数/递归函数.svg?raw=true)
![](/python期末复习/图片文件/函数/递归函数.svg?raw=true)
- 自调用函数，在函数体内部直接或间接地自调用自己，即函数的嵌套调用是函数本身。
- 通常用来实现数值计算的方法


### 6.1 原理
- 递归函数必须包括两个部分：
    - 终止条件：表示递归地结束条件，用于返回函数值，不再递归调用
    - 递归步骤：把第n步的值和第n-1步相关联，递归调用函数本身。
- 递归函数的调用过程类似于栈的入栈和出栈。
- 递归函数的执行过程
    - 每次进入递归函数时，将当前的参数和返回地址压入栈中。
    - 当递归函数执行到终止条件时，开始出栈。

### 6.2 需要注意的问题
- 必须设置终止条件：
    - 在 `sys` 模块中，函数 `getrecursionlimit()`可以查看当前系统的递归深度，默认值为1000。
    - 可以使用 `sys.setrecursionlimit()` 函数来设置递归深度。
- 必须保证收敛：子问题的规模必须小于原始问题的规模
- 必须保证内存和运算消耗控制在一定范围内

## 七.内置函数的使用
### 7.1 `eval()` 函数的使用
`eval` 函数可以对动态表达式进行求值，具体语法形式如下
```python
eval(expression,global = None,Locals = None)
'''
expression:动态表达式
globals:全局变量
locals:局部变量
'''
```

### 7.2 `exec()` 函数的使用
`exec` 函数可以执行动态代码，具体语法形式如下
```python
exec(object,globals = None,Locals = None)
'''
object:动态代码
globals:全局变量
locals:局部变量
'''
```

### 7.3 `compile()` 函数的使用
`compile` 函数可以将字符串编译成代码对象，具体语法形式如下
```python
compile(source,filename,mode,flags = 0,dont_inherit = False,optimize = -1)
'''
source:字符串或者AST对象
filename:代码文件名称，如果不是从文件读取代码则传递一些可辨认的值
mode:指定编译代码的种类，可以指定为exec,eval,single
flags:变量作用域，局部命名空间，如果被提供，可以是任何映射对象
dont_inherit:这个参数是用来控制编译函数是否继承它的全局命名空间和局部命名空间的标志
optimize:优化参数
'''
```

## 八.函数式编程
- 在Python中，函数也是对象，函数对象可以赋值给变量
- 函数对象也可以作为参数传递给函数，还可以作为函数的返回值
- 高阶函数：参数为函数对象的函数或者返回函数对象的函数称为高阶函数（函数的函数）

### 8.1  `map()` 函数
```python
map(func, *iterables)
```
`map()` 函数将一个函数 `func` 应用到一个或多个可迭代对象 `iterables` 中的每个元素上，并返回一个新的迭代器，其中包含了应用 `func` 后的结果。

### 8.2 `filter()` 函数
```python
filter(function, iterable)
```
`filter()` 函数用于过滤序列，过滤掉不符合条件的元素，返回一个迭代器对象，如果要转换为列表，可以使用 `list()` 来转换。

### 8.3 `functools.reduce()` 函数
```python
functools.reduce(function, iterable[, initializer])
```
`reduce()` 函数用于对序列中的元素进行累积操作，将一个函数 `function` 应用到序列的前两个元素上，然后将结果与第三个元素进行累积操作，以此类推，直到序列中的所有元素都被处理完毕。如果提供了 `initializer`，则将其作为初始值。

### 8.4 `functools.partial()` 函数
```python
functools.partial(func, *args, **keywords)
```
`partial()` 函数用于创建一个新的函数，该函数的参数列表中已经包含了部分参数值，返回的新函数可以接受剩余的参数值。`*args`为位置参数，`**keywords`为关键字参数。

### 8.5 `sorted()` 函数
```python
sorted(iterable, key=None, reverse=False)
```
`sorted()` 函数用于对可迭代对象进行排序，并返回一个新的已排序的列表。`key` 参数用于指定排序的关键字，`reverse` 参数用于指定排序的顺序。

### 8.6 函数装饰器
```python
@装饰器1
def 函数体1:
    函数体1

# 等价于
函数1 = 装饰器1(函数体1)
```
1. 装饰器实际上就是一个函数，用来包装函数的函数，装饰器返回一个修改之后的函数对象，且具有相同的函数签名
2. 装饰器的作用是为已经存在的函数参加额外的功能，而不需要修改函数的源代码。
